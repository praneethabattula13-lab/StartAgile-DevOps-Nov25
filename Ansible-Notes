Agenda:
=====================================
Introduction of Configuration Management
Discuss on Different CM tools
Push and Pull Approach
Introduction to Ansible
Ansible Architecture and its components
Setup Ansible Controller and worker nodes.
=========================================
Configuration
=========================================
make changes on multiple server
    -> installing packages 
    -> copying config files
    -> creating files and directories
    -> creation users and groups
    -> setting up permissions
    -> deploying applications
    -> execution of script

If we have to these changes/tasks on 200 servers manually:
    -> Time consuming 
    -> repetitive
    -> error prone
    -> application  may crash
    -> all updates may not be available
    -> keeping a track of changes will be difficult
    -> Activities should done separately for different OS

Configuration Management:
================================
> Using an automation tool to make changes on several servers in different environments in very less time .
> It is all about bringing consistency across on the servers-> this can be achieved by using an automation tool.
> An automation tool will also ensure your desired changes are always available on the servers
>If our desired configurations are not available on the servers then the tool should identify that and make change son the servers
to get desired setup.
> We write code in order to make configurations changes using the tools
> This code can be maintained in VC tool and can collaborated with other team members.
> CM tool connect to the available infra and then make changes on them
> It creates a Logs of change performed in servers.

Infrastructure as a code tool: Terraform
======================================
Writing the code to create/modify/delete infrastructure on the cloud (AWS, azure, GCP)
Using a tool to write the code and provision the infra is called as IAC tool 


Various CM tools:
==================================

PULL Approach
==============
-> puppet
-> Chef

PUSH Approach
================
-> Ansible
-> Salt stack

Pull aproach:
==================

> chef
> puppet

In the pull approach changes are pulled by the agent nodes 
The controller or the master node will not make any changes on the agent nodes
The agent nodes have a agent process installed on them
these agent process will poll the controller on the scheduled time for changes
if there are new changes computed on the master node, the agent process will pull the changes and execute on themselves.



Push approach:
=================

> saltstack
>Ansible

The code is written in the master/Controller node
These tools can connect to the agent/host nodes parallely 
These tools will then apply configuration code changes immediatly on the host/agent servers
On the host/agent servers no agent process is present
Everything is controlled by master node

===================================
Ansible:
====================================
-> It is an open source tool and use it for free
-> It is very simple tool and easy to learn 
-> It works on push approach.
-> Ansible as a tool has 2 parts:
 1. Ansible core -> Ansible to be used on the command line 
 2. Ansible tower/AWX -> It is the GUI of ansible or Ansible dashboard
 -> Ansible will always be installed on a Linux OS
 -> Ansible can connect to servers of any OS -> Linux or windows
 -> Ansible is a python based tool which required version >=2.7
 -> Ansible configuration code is written in YAML
 -> It is an agentless tools
 -> It support configuring infrastructure on the cloud also.
 
 =====================================
 INVENTORY: WHERE TO DO THE CHANGES
 ==============================
 It is a simple file in which we will write the list of Ip address or hostnames of the servers where 
 ansible can connect and make changes.
 This file is available by default with a name "hosts" and is available at the directory "/etc/ansible"
 You can create your inventory file also and place it any directory of the Ansible controller.
 
 There are 2 types of inventory file:
 
 1. Static Inventory: 
 ============================
 Inventory file is created by user 
 Ip address are written by the user in the file
 When you have limited infra then create the static file.
 
 2. Dynamic Inventory:
 =============================
 If the number of servers are auto scaling that means they are on the cloud
 then we use ansible to generate our inventory file

====================================================
Modules:
--------------------------
They are nothing but python scripts (ansible pre-written code) that are pushed to host servers to make changes.
These modules accept some input parameters from the user to configure desired changes on the servers

example : copy module -> accept input like source file location and destination

get_url : url=https://example.com/file1 dest=/tmp

Ansible works by connecting to your host servers and pushing these scripts which we call as ansible modules 
on them.

https://docs.ansible.com/ansible/2.8/modules/list_of_all_modules.html

We can create our own custom modules also in ansible using pyhton.

======================================================
Playbooks:
======================================================
Ansible code will be written in a file called as playbook 
A playbook consist of a play 
A play is nothing but:
  inventory hosts -> servers where to do changes 
  tasks to be performed
     -> modules to be executed
playbook is written in YAML

playbook with YAML code --> playbook is run on the ACM--> 
it is then converted to a python code --> this py code is copied on the worker server
ansible then executed the py program on each worker --> after the code is executed --> 
the python code is deleted from worker
In the playbook we can add -> variable, conditions, dependencies, handle errors, loops 

=========================================================
ansible.cfg file -> present in /etc/ansible 
=========================================================
All the configuration details of ansible are placed in this file.
user details, password details, module location, inventory location, fork details 
You can also create your own ansible.cfg with required parameters for the execution of the playbook
==========================================================
Create 2 EC2 servers:

Install Ansible on EC2 server:

$ sudo apt update
$ sudo apt install software-properties-common
$ sudo add-apt-repository --yes --update ppa:ansible/ansible
$ sudo apt install ansible

====================================================
CONNECT ANSIBLE CONTROLLER WITH ANSIBLE HOST:
====================================================
1. We will generate SSH keys on the controller machine 
Execute below command:
# ssh-keygen

Press enter key 3 times and keys will be generated 

2. Copy the ssh keys in the worker machine 
On the controller machine 
exeucte below command :

# cat /root/.ssh/id_rsa.pub
copy the key 

3. keys have to be copied on worker machine in ~/.ssh/authorized_keys files

Go to worker machine 

# ls -al  ==> check if you have .ssh folder 

execute below command 

# echo "your-public-key" >> ~/.ssh/authorized_keys

4. Validate Both the machine are able to communicate.

# ssh root@<privateip-worker>

you will see controller is connected to worker 

to come out of it execute below command 

# exit 

==============================
For us towrite ansible code, we go to default directory :

# cd /etc/ansible 

Update the host file with worker details 

# vim hosts 

press i

scroll to the bottom and create below host group 

[webserver]
<give-privateip-worker>

save the file and come out.

=====================================
Ansible code can be written in 2 ways :

1. Adhoc commands :
- single line commands 
- execute single module at a time 
- perform single change on the worker 
- whenever we want to quickly check something on worker we can use adhoc commands 

Syntax to write adhoc command:

# ansible <hostgorup> -m <modulename> -a "input argument"

demo:
# ansible webserver -m ping
# ansible webserver -m command -a "uptime"
# ansible webserver -m command -a "df -h"

2. Playbooks
=========================
Playbooks is used when we have to execute multiple tasks on the worker
Playbooks are written in YAML 
Playbooks is written in ACM only 
Playbooks consist of 2 main parts 
1. hosts -> host group created in hosts files
2. tasks -> modules to be executed

Structure:

- name: Give a name to the play 
  hosts: give the host group name 
  tasks:
  - name: give a unique name to your task 
    module-name: arg-name=value arg-name=value
  - name: give a unique name to your task 
    module-name: arg-name=value arg-name=value
  - name: give a unique name to your task 
    module-name: arg-name=value arg-name=value
  - name: execute a command 
    command: uptime 
  - name: install package 
    apt: name=php state=present

==================================
Register: it is a concept in ansible that will create a variable 
the variable will store/register the output of the module executed 
Playbook1 

# vim playbook1.yml 

- name: First playbook in ansible
  hosts: webserver
  tasks:
  - name: Print a greeting for the user
    debug: msg="Hello from Ansible Controller"
  - name: Execute a command
    command: hostname -s
    register: output_cmd
  - name: Print the variable
    debug: var=output_cmd

save the file 

# ansible-playbook playbook1.yml --syntax-check 

# ansible-playbook playbook1.yml


Execute a playbook to install package and create a file


# vim playbook2.yml


- name: Install packages on the worker node
  hosts: webserver
  become: true
  become_user: root
  tasks:
  - name: update the apt repo
    command: apt-get update
  - name: install php on hostserver
    package: name=php state=present
  - name: Create a file on hostserver
    file: path=/tmp/myfile state=touch


Save the file(:wq!)

# ansible-playbook playbook2.yml


===========================================
Variables in Playbooks:
==========================================

Variables -> temporary memory locations that store data 

To make our playbooks reusable use variables 
using variables, we will be able to pass new data to the parameters in the tasks sections

A variable can store a single value or a list of values  
variables can store a string, number, boolean value 
Variables are 2 types in ansible - Custom and fact variables

 
Custom variables:
=======================
  - Variables created by users 
  - variable name given by user 
  - variable value given by user 
  - These variables can be declared in a playbook or in a sperate YAML file or in a inventory file also 
  - The variable values can be referred in the tasks section as {{ var_name }} 





# vim playbookvaraibles.yml

- name: Custom Variables in Ansible 
  hosts: webserver
  become: true
  become_user: root
  vars:
    pkg_name: git
    pkg_state: present
    file_path: /tmp/mydemo
    file_state: directory
  tasks:
  - name: update the apt repo
    command: apt-get update
  - name: install {{ pkg_name }} on hostserver
    package: name={{ pkg_name }} state={{ pkg_state }}
  - name: Create a directory on hostserver
    file: path={{ file_path }} state={{ file_state }}
Save the playbook and run it.

=============================================
Store the variables in a separate file


# vim variables.yml

    pkg_name: git
    pkg_state: present
    file_path: /tmp/mydemo
    file_state: directory

Save the file (:wq!)



# vim playbook4.yml

- name: Custom Variables in Ansible 
  hosts: webserver
  become: true
  become_user: root
  # vars:  local variables- 
  vars_files:
    - variables.yml
  tasks:
  - name: update the apt repo
    command: apt-get update
  - name: install {{ pkg_name }} on hostserver
    package: name={{ pkg_name }} state={{ pkg_state }}
  - name: Create a directory on hostserver
    file: path={{ file_path }} state={{ file_state }}


Save the file and run the playbook

==============================
Run the playbook by passing values to the variables at runtime.
Use the option : --extra-vars

# ansible-playbook playbook4.yml --extra-vars "pkg_name=maven pkg_state=absent file_path=/tmp/newdemo file_state=touch"

===============================
FACT Variables:
================================
Whenever ansible controller connects to its worker nodes
 Always Ansible will gather complete information or details about each worker node
It will gather information like host details, architecture,network,ipaddress,
 BIOS information,OS,memory etc etc
This gathered information is called as FACTS

Ansible stores each fact in a variable called as fact variables.
These variables are created by Ansible and values are also computed by Ansible

These variables will always start with “ansible_variablebName”

These variable values are computed at runtime
Some of these variable values are unique to each host server

These variables are also called dynamic variables.
The value of the variable changes from host to host

User cannot create fact variable and cannot change the value of fact variable 

In ansible we have a module called as setup module.


Demo 1: See the fact variables:
==============================

 # ansible webserver -m setup
 # ansible webserver -m setup -a "filter=ansible_hostname"
 # ansible webserver -m setup -a "filter=ansible_os_family"
# ansible webserver -m setup -a "filter=ansible_distribution"
# ansible webserver -m setup -a "filter=ansible_dist*"




# vim playbook5.yml


- name: Fact variables in Ansible
  hosts: webserver
  become: true
  tasks:
  - name: install httpd package
    package: name=httpd state=present
    when: ansible_os_family == "RHEL"
  - name: install apache2 package
    package: name=apache2 state=present
    when: ansible_os_family == "Debian"

Save the file and run it

Example 2: When keyword
============================

# vim playbookWhen.yml


- name: When condition in playbook
  hosts: webserver
  become: true
  tasks:
  - name: install package on Debain machines
    package: name=apache2 state=present
    when: ansible_distribution == "Ubuntu" and ansible_distribution_major_version == "24"
  - name: Execute a command
    command: hostname -s
    when: (ansible_distribution == "Ubuntu") or
               (ansible_distribution == "Amazon") or
               (ansible_distribution == "RHEL")


Save the file and execute the file.

==============================================

# vim index.html

<h1> This is HTML file to be deployed </h1>
<h1> This file is from Ansible Controller </h1>
<h1> This file is created by Sonal </h1>
...new code

# vim playbook8.yml

- name: Deploy HTML code on worker nodes
  hosts: webserver
  vars:
    pkg_name: apache2
    dest_path: /var/www/html
  tasks: # parent tasks
  - name: update apt repo
    command: apt update
  - name: Install {{ pkg_name }} package
    package: name={{ pkg_name }} state=present
  - name: Start the {{ pkg_name }} service
    service: name={{ pkg_name }} state=started
  - name: Copy HTML code on the server
    copy: src=index.html dest={{ dest_path }}
    notify: Restart {{ pkg_name }} service
  handlers: # child tasks
  - name: Restart {{ pkg_name }} service
    service: name={{ pkg_name }} state=restarted

==================================================

Ansible Roles:

It is just a way to write ansible code 
The roles are created in /etc/ansible/roles directory 
Roles are just directories 
every role will have a unique name 
ansible-galaxy is a command used to create roles in ansible 
When we create a  role we get 7 directories inside it
Whatever we wrote in the playbook, same is written in Ansible roles but playbook sections are written in differ0ent directories
In Ansible roles there are 7 directories. the names are :
meta : describe the role
tasks: write only tasks as we wrote in playbook
handlers: write only handler task 
vars/defaults: write variable and values 
files: if tasks is needing any file write inside this directory 
template: just like files here we can  write jinja2 templates
We can create multiple roles and execute them all with single playbook 
Playbook structure will be:

hosts: webserver 
roles:
 - rolename
 - rolename
======================================
Demo:

go into roles directory 

# cd /etc/ansible/roles 

# ansible-galaxy init apache

# ls

# cd apache

# ls

#  rm -rf README.md tests templates meta

All roles folder will come an empty YAML file

# vim tasks/main.yml 


  - name: update apt repo
    command: apt update
  - name: Install {{ pkg_name }} package
    package: name={{ pkg_name }} state=present
  - name: Start the {{ pkg_name }} service
    service: name={{ pkg_name }} state=started
  - name: Copy HTML code on the server
    copy: src=index.html dest={{ dest_path }}
    notify: Restart {{ pkg_name }} service

save the file 

# vim vars/main.yml 

pkg_name: apache2
dest_path: /var/www/html


save the file 

# vim files/index.html 

<h1> This code is deployed using Ansible Roles </h1>

Save the file 

# vim handlers/main.yml 

- name: Restart {{ pkg_name }} service
  service: name={{ pkg_name }} state=restarted

Save the file 
  
To execute the role: we have to create a playbook in /etc/ansible 

# cd ..

# vim playbookroles.yml

- name: execute roles
  hosts: webserver
  roles:
    - apache

ansible-playbook playbookroles.yml 


Demo2:
===========================

# cd roles 

# ansible-galaxy init docker

# ls 

# cd docker

# vim tasks/main.yml

- name: install package {{pkg_name}}
  package: name={{pkg_name}} state=present
- name: start {{pkg_name}} service
  service: name={{service_name}} state=started
- name: Clone git repo
  git: repo={{repo_url}} dest=/tmp/gitrepo
- name: Execute the dockerfile and build docker Image
  command: chdir=/tmp/gitrepo docker build -t {{image_name}} .
- name: Deploy the image
  command: docker run -d -P {{image_name}}


Save the file 

# vim vars/main.yml 

pkg_name: docker.io
service_name: docker
repo_url: https://github.com/Sonal0409/AnsibleDockerdemo.git
image_name: myjavaapp:ansible


save the file 

cd ../..

# vim playbookroles.yml 

- name: execute roles
  hosts: webserver
  roles:
    - apache
    - docker

#  ansible-playbook playbookroles.yml

Validate the output:

#  ansible webserver -m command -a "docker images"

#  ansible webserver -m command -a "docker ps -a"

Access the application:

<publicIP>:<portnumber>/addressbook


====================================================
Ansible Dynamic Inventory:


 Ansible Dynamic Inventory
===========================

By default in ansible we have a hosts file where we write the list of Ip address of the hosts servers where we have to do the changes.
This file is static where the ip address are fixed, user will manually add new ips or remove Ipaddress that are not required.

But consider a use case where your infrastructure on the cloud and the number of servers are scaling up or scaling down dynamically.

Since the inventory on AWS is dynamic, we cannot hard code the inventory/hosts file on Ansible controller. That will not be correct approach

What is the solution then?

We will take help of Ansible where
Ansible will connect to AWS securely
We will use an ansible plugin that will check number of VMs in the desired region on AWS and fetch the ip address or hostnames on the ansible controller machine.
Once ansible collects the ipaddress of the VMs on the cloud it will automatically compute an Inventory file for the user
We will use a command to generate this inventory file
Whenever the command is run  Ansible → connect to AWS→ go to desired region → collects IP of available VMs→ displays the inventory file on the controller
Now whenever the user will run the playbook, ansible will use the dynamic inventory and execute the changes on the dynamic VMs

Steps for 1 st part:
===================================
First Prepare Ansible Controller to install packages that required to connect to AWS
Install the ansible Cloud plugin and update its details in ansible.cfg file
Create a new inventory file ->The name of the inventory file should always end with aws_ec2.yml

Steps of Part 2:

1. Create credentials on AWS, so ansible can connect to AWS
2. Create some Ec2 Vms on AWS of which ansible will fetch the inventory details.

Steps of Part3:

Ansible Controller connects to those EC2 servers using SSH
Ansible controller executes playbook on the server


Note:

The SDK is composed of two key Python packages: Botocore (the library providing the low-level functionality shared between the Python SDK and the AWS CLI) and Boto3 (the package implementing the Python SDK itself).

https://boto3.amazonaws.com/v1/documentation/api/latest/guide/quickstart.html






Execute below steps:
=============================

Whichever user you are logged in with the same user you will install the packages and run the ansible inventory command

# sudo su -

# cd /etc/ansible

# sudo apt install python3-pip

# pip3 install boto3

# pip show boto3

# sudo apt-get update

# sudo apt-get install awscli -y

Update the ansible.cfg file for it to use the aws_ec2 plugin to fetch the inventory

# vim ansible.cfg

[defaults]

enable_plugins = aws_ec2

Save the file


Create the aws_ec2 inventory file

# vim aws_ec2.yml

plugin: amazon.aws.aws_ec2
regions:
 - us-east-1


Save the file



Go to AWS create the accesskey and secret key credentials:



On the Ansible :

Take the access key and secret key and save it as environment variables on the Lab:

Run these commands

 # export AWS_ACCESS_KEY_ID= <give your key>
#export AWS_SECRET_ACCESS_KEY=<give your key>

Now execute the command to list the inventory:

# ansible-inventory -i /etc/ansible/aws_ec2.yml --list





Create Ec2 instances on AWS in us-east-1 region

On the master node run the inventory command:

# ansible-inventory -i /etc/ansible/aws_ec2.yml --list



Do these steps as Assignment:
============================================

Connecting Ansible controller to your cloud machine over SSH
===========================================


Run the Ansible command on the dynamic inventory

If we want to create 10 servers, we would not want to execute steps of creating ansiuser, copying ssh keys and updating config file manually on all server
Solution for this is : 
Take the created ANsible worker to aws that connected to Ansible controller via ssh
Convert the node as an AMI
So all the worker nodes configuration/softwares/OS/user details will be available as AMI
Now we will create new Vms with our custom AMI -> So all the new instances will have
  Ansible controller SSH keys
 Will have ansiuser and config file updates

Assignment/homework steps: 
======================================
Now go to AWS and select your EC2 worker server
Convert the Ec2 server in to an Image


Give the Image name as AnsibleHostImage→ click on create Image

You can see you image by clicking on AMI



It will take 5 mins to create the AMI
Once the AMi is available.
7. We will now create multiple Instance with the new Image itself
Click on launch Instance → neter the name and selct the AMi that we have created


Launch the instance
8 go to the master node:
# ansible-inventory -i aws_ec2.yml --list
# ansible aws_ec2 -i aws_ec2.yml -m ping
================================================
Run the playbook

# vim playbook-dynamic.yml
- name: Execute variables from vault
  hosts: aws_ec2
  become: true
  tasks:
  - name: create a user on worker node
    file: path=/tmp/file state=touch
                                                    
Save the file and run it
# ansible-playbook -i aws_ec2.yml playbook-dynamic.yml

